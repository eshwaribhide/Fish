"""
Purpose: The purpose of the tournament manager is to interact with the 1000s of players that signed up for a
tournament, the referee, and possibly tournament observers. The tournament manager allocates players to games
and creates referees for each game to run a game with certain players.
The sign-up component will also pass in all the players who have signed up to the tournament manager.

The tournament manager's constructor will take in those signed-up players. Assumption: Those are all the players that
have signed up for the tournament, so no more will need to be added via a method or anything. They will be stored
in a class attribute called "players".

I believe that it is the referee's job to deal with the remote players getting disconnected. The referee
will then tell this to the tournament manager, at the end of the game, and the tournament manager will keep track of
who those players are (along with the cheaters).

The tournament manager will have another class attribute called "blacklist", which is a list of all the players
who have cheated/failed, and they cannot be added to games or future tournaments anymore.

**Note: Please see player.py for more info on the concept of player_id, which I bring up now.**

The tournament manager will have another class attribute called played_against, which maps each Player's player_id (an int) to
a list of all the other Player ids of Players they have already played. This is necessary because I anticipate the
tournament to be round robin, so every Player will play every other Player exactly once. {player_id: [player_id]}

The tournament manager will have a class attribute called games_won, which maps a player_id (an int) to how many games the corresponding player has
won (int called win_count). This allows for the winner to be reported at the end of the tournament. {player_id: win_count}

Data Def/Assumption: One form of statistic is a leaderboard: a list of the top 10 players (assume 1000s of players have signed up),
where they are ordered based on how many games they have won. Also, another form of statistic is the Player who is the winner of the whole 
tournament (the Player who won the most games), which is reported at the end of
the tournament.

THE ONLY PUBLIC METHOD IS RUN_TOURNAMENT. ALL OTHER METHODS WILL ONLY BE CALLED BY THE TOURNAMENT MANAGER,
SO THEY ARE PRIVATE.
"""

"""
Nothing -> List of Player (the class attribute blacklist)
This is basically the main method of the tournament manager. In this method, the tournament manager will allocate 2-4
players to an instance of a game. What this means is, the tournament manager will make a list of 2-4 players and will
instantiate a Referee object that takes in that list. The tournament manager will also come up with a randomly generated
board_rows and board_columns, which also will be passed into the Referee instance. MOST LIKELY, THREADS 
WILL HAVE TO BE UTILIZED TO RUN MANY GAMES AT ONCE LATER ON, IF 1000S OF GAMES ARE RUNNING FOR EXAMPLE. Upon the end of a referee's 
run_game method, the referee returns the outcome of the game, which is how the tournament manager will be able to 
collect statistics. If any cheaters are reported, they will be added to the tournament manager's blacklist. Those cheaters cannot be
added to any more games. At the end of this method, the blacklist will be returned so that we know who cannot sign up again for another tournament. 
"""
def run_tournament():
    pass

"""
Outcome -> Nothing
An outcome looks like a Dictionary of the form {"won": List of Player objects, "lost": List of Player objects, 
"cheated/failed": List of Player objects} and is returned by the Referee's run_game method. 

This takes an Outcome, takes the games_won attribute, finds the player id of the winner(s), and then adds 1 to indicate 1 more game was won 
by the corresponding player(s).
"""
def __update_win_count(Outcome):
    pass

"""
Nothing -> {player_id: games_won} where player_id and games_won are both ints
This reports tournament statistics (the leaderboard of the top 10 player, see above) to tournament observers. 
It will probably call each the tournament observers'
get_statistics_updates method or something. I assume that if observers want to get information about ongoing actions,
then they will need to be game observers...that will be handled by the Referee.
"""
def __report_statistics():
    pass

"""
Nothing -> Player
This reports the winner to tournament observers (who won the most games). It will probably call each the tournament observers'
get_winner_updates method or something. 
"""
def __report_winner():
    pass

"""
This will create a new thread, in which a Referee's run_game method is called. For use in which we need multiple games
running at once. Not necessary right now. 
"""
def __create_game_thread():
    pass

"""
Nothing -> Referee
This instantiates a referee, used per game (will never be re-used). A List of players will be generated by calling
allocate_players, along with randomly created values for board_rows and board_columns, are used to instantiate a Referee.
"""
def __create_referee():
    pass

"""
Nothing -> List of Players
This will select 2-4 players from the referee's players class attribute and will then be used as a list when a Referee
is instantiated. It will use the played_against class attribute to make sure the selected players have not yet played
against each other. It is essentially the method that helps with allocating players.
"""
def __group_players():
    pass

"""
Nothing -> Boolean
This is a method that will basically be the stop condition for run_tournament. It will check, with the played_against
attribute, whether all players have played all other players.
"""
def __is_tournament_over():
    pass


